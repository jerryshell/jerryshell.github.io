<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>程序修改的问题与成本 - 编程即理论构建</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">编程即理论构建</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="程序修改的问题与成本"><a class="header" href="#程序修改的问题与成本">程序修改的问题与成本</a></h1>
<p>A prominent reason for proposing the Theory Building View of programming is the desire to establish an insight into programming suitable for supporting a sound understanding of program modifications.</p>
<p>提出“理论构建视角”的编程理论的一个重要原因是，希望建立一种适合支持对程序修改进行合理理解的编程洞察力。</p>
<p>This question will therefore be the first one to be taken up for analysis.</p>
<p>因此，这个问题将成为第一个被分析的对象。</p>
<p>One thing seems to be agreed by everyone, that software will be modified.</p>
<p>有一点似乎是众所周知的，即软件将会被修改。</p>
<p>It is invariably the case that a program, once in operation, will be felt to be only part of the answer to the problems at hand.</p>
<p>一旦程序投入运行，人们往往会觉得它只是解决当前问题的一部分答案。</p>
<p>Also the very use of the program itself will inspire ideas for further useful services that the program ought to provide.</p>
<p>此外，程序本身的使用也会激发人们对程序应提供的进一步有用功能的构想。</p>
<p>Hence the need for ways to handle modifications.</p>
<p>因此，需要有方法来处理修改。</p>
<p>The question of program modifications is closely tied to that of programming costs.</p>
<p>程序修改的问题与编程成本问题密切相关。</p>
<p>In the face of a need for a changed manner of operation of the program, one hopes to achieve a saving of costs by making modifications of an existing program text, rather than by writing an entirely new program.</p>
<p>面对程序运行方式需要改变的情况，人们希望通过修改现有程序文本而非编写全新程序来节省成本。</p>
<p>The expectation that program modifications at low cost ought to be possible is one that calls for closer analysis.</p>
<p>认为程序修改应以低于成本实现的预期，需要进行更深入的分析。</p>
<p>First it should be noted that such an expectation cannot be supported by analogy with modifications of other complicated man–made constructions.</p>
<p>首先需指出，此类预期无法通过类比其他复杂人造构造的修改来支撑。</p>
<p>Where modifications are occasionally put into action, for example in the case of buildings, they are well known to be expensive and in fact complete demolition of the existing building followed by new construction is often found to be preferable economically.</p>
<p>例如在建筑领域，虽然偶尔会进行修改，但众所周知这类修改成本高昂，事实上完全拆除现有建筑并重新建造往往在经济上更具优势。</p>
<p>Second, the expectation of the possibility of low cost program modifications conceivably finds support in the fact that a program is a text held in a medium allowing for easy editing.</p>
<p>其次，低成本程序修改的预期或许可从程序作为可轻松编辑的文本这一事实中获得支持。</p>
<p>For this support to be valid it must clearly be assumed that the dominating cost is one of text manipulation.</p>
<p>要使这种支持成立，必须明确假设主导成本是文本操作成本。</p>
<p>This would agree with a notion of programming as text production.</p>
<p>这与将编程视为文本生产的观念相一致。</p>
<p>On the Theory Building View this whole argument is false.</p>
<p>从理论构建视角来看，这一整个论点是错误的。</p>
<p>This view gives no support to an expectation that program modifications at low cost are generally possible.</p>
<p>这一视角无法支持低成本程序修改普遍可能的预期。</p>
<p>A further closely related issue is that of program flexibility.</p>
<p>另一个密切相关的问题是程序灵活性。</p>
<p>In including flexibility in a program we build into the program certain operational facilities that are not immediately demanded, but which are likely to turn out to be useful.</p>
<p>在程序中纳入灵活性时，我们会在程序中构建某些操作功能，这些功能并非立即被要求，但很可能最终会派上用场。</p>
<p>Thus a flexible program is able to handle certain classes of changes of external circumstances without being modified.</p>
<p>因此，一个灵活的程序能够在不进行修改的情况下处理某些类型的外部环境变化。</p>
<p>It is often stated that programs should be designed to include a lot of flexibility, so as to be readily adaptable to changing circumstances.</p>
<p>人们常说，程序应设计得具有大量灵活性，以便能够轻松适应变化的环境。</p>
<p>Such advice may be reasonable as far as flexibility that can be easily achieved is concerned.</p>
<p>这种建议在涉及易于实现的灵活性时可能是合理的。</p>
<p>However, flexibility can in general only be achieved at a substantial cost.</p>
<p>然而，灵活性通常只能以相当大的成本实现。</p>
<p>Each item of it has to be designed, including what circumstances it has to cover and by what kind of parameters it should be controlled.</p>
<p>每一项灵活性都必须经过设计，包括它需要覆盖的具体情况以及应通过何种参数进行控制。</p>
<p>Then it has to be implemented, tested, and described.</p>
<p>随后还需进行实现、测试和描述。</p>
<p>This cost is incurred in achieving a program feature whose usefulness depends entirely on future events.</p>
<p>这种成本是为实现一个其有用性完全取决于未来事件的程序功能而产生的。</p>
<p>It must be obvious that built–in program flexibility is no answer to the general demand for adapting programs to the changing circumstances of the world.</p>
<p>显然，内置程序灵活性并非应对世界变化环境下对程序适应性普遍需求的解决方案。</p>
<p>In a program modification an existing programmed solution has to be changed so as to cater for a change in the real world activity it has to match.</p>
<p>在程序修改中，现有程序解决方案必须进行调整，以适应其需要匹配的现实世界活动变化。</p>
<p>What is needed in a modification, first of all, is a confrontation of the existing solution with the demands called for by the desired modification.</p>
<p>修改所需的首要步骤是将现有解决方案与所需修改带来的需求进行对比。</p>
<p>In this confrontation the degree and kind of similarity between the capabilities of the existing solution and the new demands has to be determined.</p>
<p>在此对比过程中，必须确定现有解决方案的能力与新需求之间的相似程度和类型。</p>
<p>This need for a determination of similarity brings out the merit of the Theory Building View.</p>
<p>这种对相似性的确定需求凸显了“理论构建视角”的优势。</p>
<p>Indeed, precisely in a determination of similarity the shortcoming of any view of programming that ignores the central requirement for the direct participation of persons who possess the appropriate insight becomes evident.</p>
<p>事实上，正是通过对相似性的确定，任何忽视“具备适当洞察力的人员直接参与”这一核心要求的编程视角的缺陷便显而易见。</p>
<p>The point is that the kind of similarity that has to be recognized is accessible to the human beings who possess the theory of the program, although entirely outside the reach of what can be determined by rules, since even the criteria on which to judge it cannot be formulated.</p>
<p>关键在于，需要认定的相似性类型对掌握程序理论的人类而言是可及的，尽管它完全超出了规则可确定的范围，因为甚至用于判断它的标准也无法被明确制定。</p>
<p>From the insight into the similarity between the new requirements and those already satisfied by the program, the programmer is able to design the change of the program text needed to implement the modification.</p>
<p>通过对新需求与程序已满足需求之间相似性的洞察，程序员能够设计实现修改所需的程序文本变更。</p>
<p>In a certain sense there can be no question of a theory modification, only of a program modification.</p>
<p>从某种意义上说，这里不存在理论修改的问题，只有程序修改的问题。</p>
<p>Indeed, a person having the theory must already be prepared to respond to the kinds of questions and demands that may give rise to program modifications.</p>
<p>事实上，掌握理论的人必须已经准备好应对可能导致程序修改的各种问题和需求。</p>
<p>This observation leads to the important conclusion that the problems of program modification arise from acting on the assumption that programming consists of program text production, instead of recognizing programming as an activity of theory building.</p>
<p>这一观察导致了一个重要结论：程序修改的问题源于将编程视为程序文本生产，而非认识到编程是一种理论构建活动。</p>
<p>On the basis of the Theory Building View the decay of a program text as a result of modifications made by programmers without a proper grasp of the underlying theory becomes understandable.</p>
<p>基于理论构建视角，程序文本因程序员在缺乏对底层理论的充分理解情况下进行修改而导致的退化现象便可得到解释。</p>
<p>As a matter of fact, if viewed merely as a change of the program text and of the external behaviour of the execution, a given desired modification may usually be realized in many different ways, all correct.</p>
<p>事实上，若仅将程序文本及执行过程的外部行为视为变化，某一特定的预期修改通常可通过多种不同方式实现，且所有方式均正确。</p>
<p>At the same time, if viewed in relation to the theory of the program these ways may look very different, some of them perhaps conforming to that theory or extending it in a natural way, while others may be wholly inconsistent with that theory, perhaps having the character of unintegrated patches on the main part of the program.</p>
<p>然而，若从程序理论的角度审视，这些实现方式可能呈现出截然不同的特征：其中部分可能与理论相符或以自然方式扩展理论，而另一些则可能与理论完全不符，或许类似于对程序主体的零散补丁。</p>
<p>This difference of character of various changes is one that can only make sense to the programmer who possesses the theory of the program.</p>
<p>这种不同修改方式的本质差异，只有具备程序理论的程序员才能理解。</p>
<p>At the same time the character of changes made in a program text is vital to the longer term viability of the program.</p>
<p>同时，程序文本中修改的本质特征对程序的长期可行性至关重要。</p>
<p>For a program to retain its quality it is mandatory that each modification is firmly grounded in the theory of it.</p>
<p>为了保持程序的质量，每一次修改都必须牢固地建立在程序理论的基础上。</p>
<p>Indeed, the very notion of qualities such as simplicity and good structure can only be understood in terms of the theory of the program, since they characterize the actual program text in relation to such program texts that might have been written to achieve the same execution behaviour, but which exist only as possibilities in the programmer’s understanding.</p>
<p>事实上，简单性和良好结构等质量概念只能通过程序的理论来理解，因为它们描述了实际程序文本与那些可能被编写以实现相同执行行为的程序文本之间的关系，而这些程序文本仅存在于程序员的理解中。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="03.程序员需要构建的理论.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="05.程序的生命、死亡与复活.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="03.程序员需要构建的理论.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="05.程序的生命、死亡与复活.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
