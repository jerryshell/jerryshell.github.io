<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>程序的生命、死亡与复活 - 编程即理论构建</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">编程即理论构建</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="程序的生命死亡与复活"><a class="header" href="#程序的生命死亡与复活">程序的生命、死亡与复活</a></h1>
<p>A main claim of the Theory Building View of programming is that an essential part of any program, the theory of it, is something that could not conceivably be expressed, but is inextricably bound to human beings.</p>
<p>程序设计理论构建视角的核心主张之一是：任何程序的本质部分——其理论基础——是无法用语言表达的，但它与人类密不可分。</p>
<p>It follows that in describing the state of the program it is important to indicate the extent to which programmers having its theory remain in charge of it.</p>
<p>因此，在描述程序状态时，必须明确指出掌握其理论的程序员在多大程度上仍掌控着该程序。</p>
<p>As a way in which to emphasize this circumstance one might extend the notion of program building by notions of program life, death, and revival.</p>
<p>为了强调这一情况，可以将程序构建的概念扩展为程序的生命、死亡和复活的概念。</p>
<p>The building of the program is the same as the building of the theory of it by and in the team of programmers.</p>
<p>程序的构建与程序员团队构建其理论的过程是相同的。</p>
<p>During the program life a programmer team possessing its theory remains in active control of the program, and in particular retains control over all modifications.</p>
<p>在程序的生命周期中，拥有其理论的程序员团队始终对程序保持主动控制，特别是对所有修改保持控制。</p>
<p>The death of a program happens when the programmer team possessing its theory is dissolved.</p>
<p>程序的死亡发生在拥有其理论的程序员团队解散时。</p>
<p>A dead program may continue to be used for execution in a computer and to produce useful results.</p>
<p>一个已死的程序仍可在计算机中继续执行并产生有用结果。</p>
<p>The actual state of death becomes visible when demands for modifications of the program cannot be intelligently answered.</p>
<p>死亡的实际状态在无法合理回应对程序修改的需求时显现。</p>
<p>Revival of a program is the rebuilding of its theory by a new programmer team.</p>
<p>程序的复活是通过新程序员团队重建其理论实现的。</p>
<p>The extended life of a program according to these notions depends on the taking over by new generations of programmers of the theory of the program.</p>
<p>根据这些概念，程序的延长寿命取决于新世代程序员接管程序的理论。</p>
<p>For a new programmer to come to possess an existing theory of a program it is insufficient that he or she has the opportunity to become familiar with the program text and other documentation.</p>
<p>对于新程序员而言，仅有机会熟悉程序文本和其他文档是不够的。</p>
<p>What is required is that the new programmer has the opportunity to work in close contact with the programmers who already possess the theory, so as to be able to become familiar with the place of the program in the wider context of the relevant real world situations and so as to acquire the knowledge of how the program works and how unusual program reactions and program modifications are handled within the program theory.</p>
<p>所需的是，新程序员有机会与已经掌握该理论的程序员密切合作，以便能够了解该程序在相关现实世界情境的更广泛背景中的位置，并掌握该程序如何运作以及如何在程序理论框架内处理异常程序反应和程序修改的知识。</p>
<p>This problem of education of new programmers in an existing theory of a program is quite similar to that of the educational problem of other activities where the knowledge of how to do certain things dominates over the knowledge that certain things are the case, such as writing and playing a music instrument.</p>
<p>新程序员在现有程序理论中的教育问题，与其他活动中的教育问题非常相似，即在这些活动中，如何做某些事情的知识主导着某些事情是事实的知识，例如写作和演奏乐器。</p>
<p>The most important educational activity is the student’s doing the relevant things under suitable supervision and guidance.</p>
<p>最重要的教育活动是学生在适当的监督和指导下进行相关活动。</p>
<p>In the case of programming the activity should include discussions of the relation between the program and the relevant aspects and activities of the real world, and of the limits set on the real world matters dealt with by the program.</p>
<p>在编程领域，该活动应包括对程序与现实世界相关方面及活动之间关系的讨论，以及对程序处理的现实世界事务所设定的限制的探讨。</p>
<p>A very important consequence of the Theory Building View is that program revival, that is reestablishing the theory of a program merely from the documentation, is strictly impossible.</p>
<p>理论构建视角的一个非常重要的后果是，程序复活，即仅凭文档重新建立程序的理论，是严格不可能的。</p>
<p>Lest this consequence may seem unreasonable it may be noted that the need for revival of an entirely dead program probably will rarely arise, since it is hardly conceivable that the revival would be assigned to new programmers without at least some knowledge of the theory had by the original team.</p>
<p>为了避免这一后果显得不合理，可以指出，完全死去的程序需要复活的情况可能很少发生，因为很难想象复活任务会交给没有至少一些原始团队理论知识的新程序员。</p>
<p>Even so the Theory Building View suggests strongly that program revival should only be attempted in exceptional situations and with full awareness that it is at best costly, and may lead to a revived theory that differs from the one originally had by the program authors and so may contain discrepancies with the program text.</p>
<p>即便如此，理论构建视角强烈建议，程序复活仅应在特殊情况下尝试，且需充分意识到此举至少成本高昂，且可能导致复活后的理论与程序作者原有的理论存在差异，从而与程序文本产生不一致。</p>
<p>In preference to program revival, the Theory Building View suggests, the existing program text should be discarded and the new–formed programmer team should be given the opportunity to solve the given problem afresh.</p>
<p>相较于程序复活，理论构建视角建议应放弃现有程序文本，并给予新组建的程序员团队机会从头解决给定问题。</p>
<p>Such a procedure is more likely to produce a viable program than program revival, and at no higher, and possibly lower, cost.</p>
<p>此类程序更可能产生可行程序，且成本不会更高，甚至可能更低。</p>
<p>The point is that building a theory to fit and support an existing program text is a difficult, frustrating, and time consuming activity.</p>
<p>关键在于，为现有程序文本构建并支撑理论是一项困难、令人沮丧且耗时的活动。</p>
<p>The new programmer is likely to feel torn between loyalty to the existing program text, with whatever obscurities and weaknesses it may contain, and the new theory that he or she has to build up, and which, for better or worse, most likely will differ from the original theory behind the program text.</p>
<p>新程序员可能会在对现有程序文本的忠诚（无论其包含多少模糊点和弱点）与需要构建的新理论之间感到矛盾，而无论好坏，新理论很可能与程序文本背后的原始理论存在差异。</p>
<p>Similar problems are likely to arise even when a program is kept continuously alive by an evolving team of programmers, as a result of the differences of competence and background experience of the individual programmers, particularly as the team is being kept operational by inevitable replacements of the individual members.</p>
<p>即使程序由不断更迭的开发团队持续维护，类似问题也可能出现，这源于个体开发者在能力和背景经验上的差异，尤其当团队因不可避免的人员替换而维持运营时。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="04.程序修改的问题与成本.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="06.方法和理论构建.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="04.程序修改的问题与成本.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="06.方法和理论构建.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
