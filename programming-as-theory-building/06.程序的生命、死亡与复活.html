<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>程序的生命、死亡与复活 - 编程即理论构建</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">编程即理论构建</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="程序的生命死亡与复活"><a class="header" href="#程序的生命死亡与复活">程序的生命、死亡与复活</a></h1>
<p>A main claim of the Theory Building View of programming is that an essential part of any program, the theory of it, is something that could not conceivably be expressed, but is inextricably bound to human beings.</p>
<p>“编程即理论构建”的核心主张是：任何程序的理论本质上无法被完整表达，且必然与人类认知紧密绑定。</p>
<p>It follows that in describing the state of the program it is important to indicate the extent to which programmers having its theory remain in charge of it.</p>
<p>描述程序生命状态时，必须明确掌握其理论的人员对该程序的实际掌控程度。</p>
<p>As a way in which to emphasize this circumstance one might extend the notion of program building by notions of program life, death, and revival.</p>
<p>为强调这一状况，可通过引入程序生命、死亡与复活的概念来扩展程序构建的内涵。</p>
<p>The building of the program is the same as the building of the theory of it by and in the team of programmers.</p>
<p>程序的构建过程，就是程序员团队在其内部构建相关理论的过程。</p>
<p>During the program life a programmer team possessing its theory remains in active control of the program, and in particular retains control over all modifications.</p>
<p>在程序生命期间，掌握其理论知识的程序员团队持续主导程序，特别是掌控所有修改权。</p>
<p>The death of a program happens when the programmer team possessing its theory is dissolved.</p>
<p>程序的死亡发生在掌握其理论的程序员团队解散时。</p>
<p>A dead program may continue to be used for execution in a computer and to produce useful results.</p>
<p>一个死亡的程序仍可在计算机中运行并产出有用结果。</p>
<p>The actual state of death becomes visible when demands for modifications of the program cannot be intelligently answered.</p>
<p>当修改需求无法得到专业回应时，程序的实际死亡状态就显现出来了。</p>
<p>Revival of a program is the rebuilding of its theory by a new programmer team.</p>
<p>程序的复活是指新程序员团队重建其理论的过程。</p>
<p>The extended life of a program according to these notions depends on the taking over by new generations of programmers of the theory of the program.</p>
<p>根据这些概念，程序的寿命取决于新一代程序员能否继承该程序的理论。</p>
<p>For a new programmer to come to possess an existing theory of a program it is insufficient that he or she has the opportunity to become familiar with the program text and other documentation.</p>
<p>新程序员若想掌握既有程序理论，仅靠熟悉程序文本和相关文档是远远不够的。</p>
<p>What is required is that the new programmer has the opportunity to work in close contact with the programmers who already possess the theory, so as to be able to become familiar with the place of the program in the wider context of the relevant real world situations and so as to acquire the knowledge of how the program works and how unusual program reactions and program modifications are handled within the program theory.</p>
<p>新程序员必须有机会与掌握理论的原团队紧密协作，通过参与相关现实场景实践来理解程序的定位，并学习程序运作机制及程序理论框架下如何处理异常反应和修改需求。</p>
<p>This problem of education of new programmers in an existing theory of a program is quite similar to that of the educational problem of other activities where the knowledge of how to do certain things dominates over the knowledge that certain things are the case, such as writing and playing a music instrument.</p>
<p>新程序员学习已有程序理论的培养问题，本质上类似音乐创作或乐器演奏，核心在于实践经验的传递，而非理论知识灌输。</p>
<p>The most important educational activity is the student’s doing the relevant things under suitable supervision and guidance.</p>
<p>最重要的教育方式就是让学生在专业指导下动手实践。</p>
<p>In the case of programming the activity should include discussions of the relation between the program and the relevant aspects and activities of the real world, and of the limits set on the real world matters dealt with by the program.</p>
<p>在编程领域，最关键的实践教学要包含两项内容：讨论程序与现实世界的具体关联，以及明确程序处理现实事务的边界。</p>
<p>A very important consequence of the Theory Building View is that program revival, that is reestablishing the theory of a program merely from the documentation, is strictly impossible.</p>
<p>“编程即理论构建”一个重要的结论是：仅凭文档绝对无法复活程序（即重建其理论）。</p>
<p>Lest this consequence may seem unreasonable it may be noted that the need for revival of an entirely dead program probably will rarely arise, since it is hardly conceivable that the revival would be assigned to new programmers without at least some knowledge of the theory had by the original team.</p>
<p>退一万步说，即便程序复活看似不可行，但现实中完全死亡的程序需要复活的情况也极少，毕竟很难想象会让对原始理论毫无了解的新团队执行复活任务。</p>
<p>Even so the Theory Building View suggests strongly that program revival should only be attempted in exceptional situations and with full awareness that it is at best costly, and may lead to a revived theory that differs from the one originally had by the program authors and so may contain discrepancies with the program text.</p>
<p>即便如此，“编程即理论构建”仍然强烈主张：程序复活只能在极特殊情况下尝试，且必须事先有心理准备，即便成功也要付出高昂代价，甚至复活后的理论可能偏离原团队的认知，与程序代码遗留潜在冲突。</p>
<p>In preference to program revival, the Theory Building View suggests, the existing program text should be discarded and the new–formed programmer team should be given the opportunity to solve the given problem afresh.</p>
<p>“编程即理论构建”主张：与其复活旧程序，不如放弃现有代码，让新团队从头解决原始问题。</p>
<p>Such a procedure is more likely to produce a viable program than program revival, and at no higher, and possibly lower, cost.</p>
<p>这种做法比复活程序更可能产出可行程序，成本相当甚至更低。</p>
<p>The point is that building a theory to fit and support an existing program text is a difficult, frustrating, and time consuming activity.</p>
<p>关键在于：强行根据现有代码反推理论体系，是个极其痛苦、挫败且耗时的过程。​</p>
<p>The new programmer is likely to feel torn between loyalty to the existing program text, with whatever obscurities and weaknesses it may contain, and the new theory that he or she has to build up, and which, for better or worse, most likely will differ from the original theory behind the program text.</p>
<p>新程序员会陷入撕裂感：既要忠于可能晦涩脆弱的现有代码，又必须构建新理论体系。而无论好坏，新理论几乎必然偏离代码背后的原始设计理念。</p>
<p>Similar problems are likely to arise even when a program is kept continuously alive by an evolving team of programmers, as a result of the differences of competence and background experience of the individual programmers, particularly as the team is being kept operational by inevitable replacements of the individual members.</p>
<p>即便在持续维护的程序中，随着程序员团队的人员更替和个体能力差异，最终也会出现类似问题，团队对程序理论的理解会不断偏离最初版本。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="05.程序修改的问题与成本.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="07.编程方法和理论构建.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="05.程序修改的问题与成本.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="07.编程方法和理论构建.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
