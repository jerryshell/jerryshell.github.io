<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>编程即理论构建</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">编程即理论构建</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>PDF: https://pablo.rauzy.name/dev/naur1985programming.pdf</p>
<p>Peter Naur’s classic 1985 essay "Programming as Theory Building" argues that a program is not its source code.</p>
<p>Peter Naur 在 1985 年的经典文章《编程即理论构建》中提出：程序并非其源代码文字本身。</p>
<p>A program is a shared mental construct (he uses the word theory) that lives in the minds of the people who work on it.</p>
<p>程序是一种存在于开发者脑海中的心理构建（他称之为“理论”）。</p>
<p>If you lose the people, you lose the program.</p>
<p>开发团队一旦流失，程序便不复存在。</p>
<p>The code is merely a written representation of the program, and it’s lossy, so you can’t reconstruct a program from its code.</p>
<p>源代码只是程序的书面记录，这种记录本身有信息缺失，所以不可能单靠代码还原出真正的程序。</p>
<hr />
<h1 id="引言"><a class="header" href="#引言">引言</a></h1>
<p>The present discussion is a contribution to the understanding of what programming is.</p>
<p>本文旨在加深对编程本质的理解。</p>
<p>It suggests that programming properly should be regarded as an activity by which the programmers form or achieve a certain kind of insight, a theory, of the matters at hand.</p>
<p>文章提出：编程应当是一种活动，程序员通过它来掌握对实际问题的深刻理解，即“理论”。</p>
<p>This suggestion is in contrast to what appears to be a more common notion, that programming should be regarded as a production of a program and certain other texts.</p>
<p>这种观点和主流看法不同：很多人认为编程就是产出程序代码及其他某些文本的过程。</p>
<p>Some of the background of the views presented here is to be found in certain observations of what actually happens to programs and the teams of programmers dealing with them, particularly in situations arising from unexpected and perhaps erroneous program executions or reactions, and on the occasion of modifications of programs.</p>
<p>本文观点的部分依据，来源于对程序和开发团队实际情况的观察，特别是当程序出现意外或错误时，以及需要修改程序时，他们的具体表现。</p>
<p>The difficulty of accommodating such observations in a production view of programming suggests that this view is misleading.</p>
<p>“编程即代码产出”的观点很难解释这些实际情况，这就证明它是有问题的。</p>
<p>The theory building view is presented as an alternative.</p>
<p>本文提出将“编程即理论构建”这一观点作为替代。</p>
<p>A more general background of the presentation is a conviction that it is important to have an appropriate understanding of what programming is.</p>
<p>本文的深层动机源于一个坚定信念：准确理解编程的本质至关重要。</p>
<p>If our understanding is inappropriate we will misunderstand the difficulties that arise in the activity and our attempts to overcome them will give rise to conflicts and frustrations.</p>
<p>如果理解不当，我们就会误判实践中遇到的困难，尝试解决时反而会引发冲突与挫败。（南辕北辙）</p>
<p>In the present discussion some of the crucial background experience will first be outlined.</p>
<p>本文首先会概述部分关键的背景实践经验。</p>
<p>This is followed by an explanation of a theory of what programming is, denoted the Theory Building View.</p>
<p>随后将阐释一种编程本质的理论：“编程即理论构建”。</p>
<p>The subsequent sections enter into some of the consequences of the Theory Building View.</p>
<p>后续章节将深入探讨“编程即理论构建”的关键意义。​​</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编程与程序员的知识"><a class="header" href="#编程与程序员的知识">编程与程序员的知识</a></h1>
<p>I shall use the word programming to denote the whole activity of design and implementation of programmed solutions.</p>
<p>我会用"编程"这个词，指代设计并实现程序解决方案的完整过程。</p>
<p>What I am concerned with is the activity of matching some significant part and aspect of an activity in the real world to the formal symbol manipulation that can be done by a program running on a computer.</p>
<p>我关注的是：如何把现实世界活动的关键部分，转化为计算机程序能够处理的符号操作。</p>
<p>With such a notion it follows directly that the programming activity I am talking about must include the development in time corresponding to the changes taking place in the real world activity being matched by the program execution, in other words program modifications.</p>
<p>由此，编程活动必须包含持续调整：当现实世界活动变化时，程序也必须随之修改。</p>
<p>One way of stating the main point I want to make is that programming in this sense primarily must be the programmers’ building up knowledge of a certain kind, knowledge taken to be basically the programmers’ immediate possession, any documentation being an auxiliary, secondary product.</p>
<p>我想要阐明的核心观点之一是：编程的本质必须是程序员的知识积累，这些知识必须是程序员直接掌握的，所有文档都只是辅助的次要产物。</p>
<p>As a background of the further elaboration of this view given in the following sections, the remainder of the present section will describe some real experience of dealing with large programs that has seemed to me more and more significant as I have pondered over the problems.</p>
<p>为后面几节详细阐述该观点作铺垫，本节剩余内容将描述我处理大型程序的实际经历，随着对这些问题的深入思考，这些经历显得愈发重要。</p>
<p>In either case the experience is my own or has been communicated to me by persons having first hand contact with the activity in question.</p>
<p>这些经验要么来自我的亲身经历，要么来自直接参与相关活动的一线人员反馈。</p>
<p>Case 1 concerns a compiler.</p>
<p>案例 1 涉及一个编译器。</p>
<p>It has been developed by a group A for a Language L and worked very well on computer X.</p>
<p>该编译器由 A 团队为语言 L 开发，并在计算机 X 上运行良好。</p>
<p>Now another group B has the task to write a compiler for a language L + M, a modest extension of L, for computer Y.</p>
<p>另一个团队 B 接到任务，要为计算机 Y 开发新编译器，新语言是 L 的小幅扩展版 L + M。</p>
<p>Group B decides that the compiler for L developed by group A will be a good starting point for their design, and get a contract with group A that they will get support in the form of full documentation, including annotated program texts and much additional written design discussion, and also personal advice.</p>
<p>B 团队认为 A 团队开发的 L 语言编译器是理想起点，于是与 A 团队签约获得全套支持：包括带注释的源码、大量设计文档及人工指导。</p>
<p>The arrangement was effective and group B managed to develop the compiler they wanted.</p>
<p>这项合作方案高效落实，最终 B 团队如愿研制出了他们想要的编译器。</p>
<p>In the present context the significant issue is the importance of the personal advice from group A in the matters that concerned how to implement the extensions M to the language.</p>
<p>在本案例中，最关键的事实是：当团队 B 为语言 L 添加 M 扩展功能时，来自团队 A 的真人指导起到了决定性作用。</p>
<p>During the design phase group B made suggestions for the manner in which the extensions should be accommodated and submitted them to group A for review.</p>
<p>在设计阶段，B 团队就扩展功能的实现方案提出建议，并提交给 A 团队审核。</p>
<p>In several major cases it turned out that the solutions suggested by group B were found by group A to make no use of the facilities that were not only inherent in the structure of the existing compiler but were discussed at length in its documentation, and to be based instead on additions to that structure in the form of patches that effectively destroyed its power and simplicity.</p>
<p>结果发现：B 团队提出的方案多次忽略现有编译器的内置特性（这些特性不仅本身存在，文档也详细说明过），反而通过打补丁的方式破坏其核心结构与简洁性。</p>
<p>The members of group A were able to spot these cases instantly and could propose simple and effective solutions, framed entirely within the existing structure.</p>
<p>A 团队成员总能立刻识别出问题，并提出巧妙解决方案，这些方案完全利用了现有结构优势。</p>
<p>This is an example of how the full program text and additional documentation is insufficient in conveying to even the highly motivated group B the deeper insight into the design, that theory which is immediately present to the members of group A.</p>
<p>即便有完整的代码和文档，实力强劲的 B 团队也无法掌握原始编译器的设计精髓，而这些核心理论在 A 团队成员心中早已不言自明。</p>
<p>In the years following these events the compiler developed by group B was taken over by other programmers of the same organization, without guidance from group A.</p>
<p>此后数年里，该编译器移交给了同一机构的其它程序员维护，且未再获得 A 团队的指导。</p>
<p>Information obtained by a member of group A about the compiler resulting from the further modification of it after about 10 years made it clear that at that later stage the original powerful structure was still visible, but made entirely ineffective by amorphous additions of many different kinds.</p>
<p>大约 10 年后，A 团队成员在后续修改中发现：原始编译器的强大架构核心虽然可见，却被各种混乱的代码堆砌破坏得面目全非，完全丧失了所有结构性优势。​</p>
<p>Thus, again, the program text and its documentation has proved insufficient as a carrier of some of the most important design ideas.</p>
<p>由此可见，程序代码和文档根本承载不了最核心的设计理念。</p>
<p>Case 2 concerns the installation and fault diagnosis of a large real–time system for monitoring industrial production activities.</p>
<p>案例 2 涉及一套用于工业生产监控的大型实时系统的安装部署和故障排查。</p>
<p>The system is marketed by its producer, each delivery of the system being adapted individually to its specific environment of sensors and display devices.</p>
<p>该系统的制造商负责销售，每次交付时都会根据具体使用环境单独定制传感器和显示设备。</p>
<p>The size of the program delivered in each installation is of the order of 200,000 lines.</p>
<p>每个交付系统的程序规模约 20 万行代码。</p>
<p>The relevant experience from the way this kind of system is handled concerns the role and manner of work of the group of installation and fault finding programmers.</p>
<p>这类系统的核心经验在于：安装和故障排查团队的角色与工作方式。</p>
<p>The facts are, first that these programmers have been closely concerned with the system as a full time occupation over a period of several years, from the time the system was under design.</p>
<p>具体而言，这些程序员从系统设计阶段就全职深度参与，持续投入多年时间。</p>
<p>Second, when diagnosing a fault these programmers rely almost exclusively on their ready knowledge of the system and the annotated program text, and are unable to conceive of any kind of additional documentation that would be useful to them.</p>
<p>其次，当进行故障诊断时，这些程序员几乎完全依赖自身对系统的实战经验和带注释的源代码，根本无法想得到其他对他们有用的补充文档类型。</p>
<p>Third, other programmers’ groups who are responsible for the operation of particular installations of the system, and thus receive documentation of the system and full guidance on its use from the producer’s staff, regularly encounter difficulties that upon consultation with the producer’s installation and fault finding programmer are traced to inadequate understanding of the existing documentation, but which can be cleared up easily by the installation and fault finding programmers.</p>
<p>第三，负责具体系统部署的客户团队虽然拿到了厂商的完整文档和使用指南，却常因理解不足而卡壳，但厂商的安装调试程序员每次都能轻松解决问题。</p>
<p>The conclusion seems inescapable that at least with certain kinds of large programs, the continued adaption, modification, and correction of errors in them, is essentially dependent on a certain kind of knowledge possessed by a group of programmers who are closely and continuously connected with them.</p>
<p>核心结论是：对于某些大型程序而言，其持续调整、修改和纠错能力，本质上依赖于特定程序员团队的专有知识，这些程序员必须与程序保持长期密切接触。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ryle-的理论概念"><a class="header" href="#ryle-的理论概念">Ryle 的理论概念</a></h1>
<p>If it is granted that programming must involve, as the essential part, a building up of the programmers’ knowledge, the next issue is to characterize that knowledge more closely.</p>
<p>既然编程的核心是构建程序员的知识，那么接下来就需要具体说明这种知识的本质。</p>
<p>What will be considered here is the suggestion that the programmers’ knowledge properly should be regarded as a theory, in the sense of Ryle [11].</p>
<p>本文研究认为：应当将程序员的知识视作一种理论：按照 Ryle [11] 定义的知识论意义上的理论。</p>
<p>Very briefly, a person who has or possesses a theory in this sense knows how to do certain things and in addition can support the actual doing with explanations, justifications, and answers to queries, about the activity of concern.</p>
<p>简而言之，掌握这种理论的人不仅懂得如何操作，还能对自己的操作进行解释、论证并解答相关疑问。</p>
<p>It may be noted that Ryle’s notion of theory appears as an example of what K. Popper [10] calls unembodied World objects and thus has a defensible philosophical standing.</p>
<p>值得注意：Ryle 的理论概念，在 K. Popper [10] 的理论框架中属于客观知识，是具有公认学术根基的哲学立场。</p>
<p>In the present section we shall describe Ryle’s notion of theory in more detail.</p>
<p>本节将详细阐述 Ryle 提出的理论概念。</p>
<p>Ryle [11] develops his notion of theory as part of his analysis of the nature of intellectual activity, particularly the manner in which intellectual activity differs from, and goes beyond, activity that is merely intelligent.</p>
<p>Ryle 在著作 [11] 中提出：理论是区分知识活动和普通智能活动的本质特征，并解释了前者如何超越后者。</p>
<p>In intelligent behaviour the person displays, not any particular knowledge of facts, but the ability to do certain things, such as to make and appreciate jokes, to talk grammatically, or to fish.</p>
<p>在智力行为中，人展现的不是具体的知识储备，而是某些能力，比如讲笑话接梗、语法正确的谈话，或是钓鱼这类技巧。</p>
<p>More particularly, the intelligent performance is characterized in part by the person’s doing them well, according to certain criteria, but further displays the person’s ability to apply the criteria so as to detect and correct lapses, to learn from the examples of others, and so forth.</p>
<p>进一步说，智力行为的特点是：行动不仅符合特定标准，更能主动应用这些标准来发现偏差、纠正错误，并借鉴他人经验。</p>
<p>It may be noted that this notion of intelligence does not rely on any notion that the intelligent behaviour depends on the person’s following or adhering to rules, prescriptions, or methods.</p>
<p>需要特别指出：这种智力行为的本质，并不基于“人类必须遵循特定规则、方法或指令”的观念。</p>
<p>On the contrary, the very act of adhering to rules can be done more or less intelligently; if the exercise of intelligence depended on following rules there would have to be rules about how to follow rules, and about how to follow the rules about following rules, etc. in an infinite regress, which is absurd.</p>
<p>相反，遵循规则这件事本身就有智商高低之分，如果智力活动真要靠遵守规则才能实现，那就会陷入无限套娃：遵守规则需要先有规则，遵守规则的方法又需要新的规则，永无止境，这显然是荒谬的。</p>
<p>What characterizes intellectual activity, over and beyond activity that is merely intelligent, is the person’s building and having a theory, where theory is understood as the knowledge a person must have in order not only to do certain things intelligently but also to explain them, to answer queries about them, to argue about them, and so forth.</p>
<p>知识活动区别于普通智能行为的本质特征在于：人类不仅需要掌握智能操作的能力，更要构建一套理论体系，这套理论能让人解释行为逻辑、解答相关疑问、进行深度论证，从而超越单纯的行为层面。</p>
<p>A person who has a theory is prepared to enter into such activities; while building the theory the person is trying to get it.</p>
<p>掌握理论的人准备投入这些活动，而构建理论的人则在尝试掌握它。</p>
<p>The notion of theory in the sense used here applies not only to the elaborate constructions of specialized fields of enquiry, but equally to activities that any person who has received education will participate in on certain occasions.</p>
<p>此处提出的“理论”概念，既适用于专业领域的复杂构建，也适用于任何受过教育的人在特定情境下参与的活动。</p>
<p>Even quite unambitious activities of everyday life may give rise to people’s theorizing, for example in planning how to place furniture or how to get to some place by means of certain means of transportation.</p>
<p>即使是生活中最普通的琐事，比如规划家具摆放位置或研究乘车路线，也会引发人们的理论化思考。</p>
<p>The notion of theory employed here is explicitly not confined to what may be called the most general or abstract part of the insight.</p>
<p>此处所指的“理论”概念，既涵盖最抽象的认知框架，也包括具体的实践细节。</p>
<p>For example, to have Newton’s theory of mechanics as understood here it is not enough to understand the central laws, such as that force equals mass times acceleration.</p>
<p>例如，这里理解牛顿力学的“理论”，光懂核心定律（比如力等于质量乘加速度）是远远不够的。</p>
<p>In addition, as described in more detail by Kuhn [4], the person having the theory must have an understanding of the manner in which the central laws apply to certain aspects of reality, so as to be able to recognize and apply the theory to other similar aspects.</p>
<p>此外 Kuhn [4] 指出，真正掌握“理论”的人必须理解核心定律如何处理实际问题，才能将理论应用于新的相似情况。</p>
<p>A person having Newton’s theory of mechanics must thus understand how it applies to the motions of pendulums and the planets, and must be able to recognize similar phenomena in the world, so as to be able to employ the mathematically expressed rules of the theory properly.</p>
<p>因此，掌握牛顿力学理论的人必须理解钟摆运动、行星运行等现象背后的原理，并能识别现实中的类似现象，从而正确运用该理论的数学公式。</p>
<p>The dependence of a theory on a grasp of certain kinds of similarity between situations and events of the real world gives the reason why the knowledge held by someone who has the theory could not, in principle, be expressed in terms of rules.</p>
<p>“理论”依赖于把握现实世界中情境与事件之间的相似性，所以这种知识无法通过规则来表述。</p>
<p>In fact, the similarities in question are not, and cannot be, expressed in terms of criteria, no more than the similarities of many other kinds of objects, such as human faces, tunes, or tastes of wine, can be thus expressed.</p>
<p>现实世界中的这类相似性本质上无法用标准定义，就像人脸、旋律或酒香的差异，既难以量化，更无法精确描述。</p>
<hr />
<ol>
<li>Brooks, R. E. Studying programmer behaviour experimentally. Comm. ACM 23(4): 207–213, 1980.</li>
<li>Feyerabend, P. Against Method. London, Verso Editions, 1978; ISBN: 86091–700–2.</li>
<li>Floyd, C. Eine Untersuchung von Software–Entwicklungs–Methoden. Pp. 248–274 in Programmierumgebungen und Compiler, ed H. Morgenbrod and W. Sammer, Tagung I/1984 des German Chapter of the ACM, Stuttgart, Teubner Verlag, 1984; ISBN: 3–519–02437–3.</li>
<li>Kuhn, T.S. The Structure of Scientific Revolutions, Second Edition. Chicago, University of Chicago Press, 1970; ISBN: 0–226–45803–2.</li>
<li>Medawar, P. Pluto’s Republic. Oxford, University Press, 1982: ISBN: 0–19–217726–5.</li>
<li>Moher, T., and Schneider, G. M. Methodology and experimental research in software engineering, Int. J. Man–Mach. Stud. 16: 65–87, 1. Jan. 1982.</li>
<li>Oskarsson, ¨O Mechanisms of modifiability in large software systems Link¨oping Studies in Science and Technology, Dissertations, no. 77, Link¨oping, 1982; ISBN: 91–7372–527–7.</li>
<li>Polya, G. How To Solve It . New York, Doubleday Anchor Book, 1957.</li>
<li>Polya, G. Mathematics and Plausible Reasoning. New Jersey, Princeton University Press, 1954.</li>
<li>Popper, K. R., and Eccles, J. C. The Self and Its Brain. London, Routledge and Kegan Paul, 1977.</li>
<li>Ryle, G. The Concept of Mind. Harmondsworth, England, Penguin, 1963, first published 1949. Applying “Theory Building”</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="程序员需要构建的理论"><a class="header" href="#程序员需要构建的理论">程序员需要构建的理论</a></h1>
<p>In terms of Ryle’s notion of theory, what has to be built by the programmer is a theory of how certain affairs of the world will be handled by, or supported by, a computer program.</p>
<p>按照 Ryle 的理论概念，程序员必须构建一套核心认知：理解计算机程序将如何支撑和处理现实世界中的具体事务。</p>
<p>On the Theory Building View of programming the theory built by the programmers has primacy over such other products as program texts, user documentation, and additional documentation such as specifications.</p>
<p>根据“编程即理论构建”的观点，程序员构建的理论比程序代码、用户文档或需求说明书等其他产物更重要。</p>
<p>In arguing for the Theory Building View, the basic issue is to show how the knowledge possessed by the programmer by virtue of his or her having the theory necessarily, and in an essential manner, transcends that which is recorded in the documented products.</p>
<p>要论证“编程即理论构建”这一观点，核心在于证明程序员通过理论掌握的知识必然超越、且本质上高于代码文档等有记录产物。</p>
<p>The answers to this issue is that the programmer’s knowledge transcends that given in documentation in at least three essential areas:</p>
<p>对于这一点，程序员的认知将在至少三个核心维度上超越书面内容：</p>
<h2 id="1"><a class="header" href="#1">1</a></h2>
<p>The programmer having the theory of the program can explain how the solution relates to the affairs of the world that it helps to handle.</p>
<p>掌握程序理论的人能解释清楚：程序解决方案如何关联并处理现实世界中的具体事务。</p>
<p>Such an explanation will have to be concerned with the manner in which the af fairs of the world, both in their overall characteristics and their details, are, in some sense, mapped into the pro gram text and into any additional documentation.</p>
<p>这种解释本质上需要揭示：现实世界的各种情况（无论整体框架或具体细节）究竟如何被映射进程序代码及文档中，并确保其可理解性。</p>
<p>Thus the programmer must be able to explain, for each part of the program text and for each of its overall structural characteristics, what aspect or activity of the world is matched by it.</p>
<p>程序员必须能阐明：现实世界中的哪些具体情况，是通过代码的每个部分及整体架构来实现的。</p>
<p>Conversely, for any aspect or activity of the world the programmer is able to state its manner of mapping into the program text.</p>
<p>反之，对于现实世界的任何情况，程序员都能准确说明它被转化成程序代码的具体方式。</p>
<p>By far the largest part of the world aspects and activities will of course lie out side the scope of the program text, being irrelevant in the context.</p>
<p>当然，现实世界中绝大多数活动将超出程序文本的范围，它们在当前上下文中无关紧要。</p>
<p>However, the decision that a part of the world is relevant can only be made by someone who un derstands the whole world.</p>
<p>然而，只有理解全局的人才能判断现实世界的哪些事务需要程序处理。</p>
<p>This understanding must be contributed by the programmer.</p>
<p>这种全局理解能力必须由程序员来提供。</p>
<h2 id="2"><a class="header" href="#2">2</a></h2>
<p>The programmer having the theory of the program can explain why each part of the program is what it is, in other words is able to support the actual program text with a justification of some sort.</p>
<p>掌握程序理论的人能解释每一段代码的设计依据，换句话说，他们能用理论依据证明代码的合理性。</p>
<p>The final basis of the justification is and must always remain the programmer’s direct, intuitive knowledge or estimate.</p>
<p>程序合理性的根本依据，始终是程序员的直接直觉认知或预判。</p>
<p>This holds even where the justification makes use of reasoning, perhaps with application of design rules, quantitative estimates, comparisons with alternatives, and such like, the point being that the choice of the principles and rules, and the decision that they are relevant to the situation at hand, again must in the final analysis remain a matter of the programmer’s direct knowledge.</p>
<p>即便在运用设计规则、量化分析或方案对比时，程序合理性的根本依据仍是程序员的直觉判断。因为选择哪些规则、判断规则是否适用，归根结底都依赖程序员的直接认知。​</p>
<h2 id="3"><a class="header" href="#3">3</a></h2>
<p>The programmer having the theory of the program is able to respond constructively to any demand for a modification of the program so as to support the affairs of the world in a new manner.</p>
<p>掌握程序理论的人能有效响应程序修改需求，使程序以新的方式处理现实事务。</p>
<p>Designing how a modifi cation is best incorporated into an established program depends on the perception of the similarity of the new demand with the operational facilities already built into the program.</p>
<p>设计程序修改方案的核心在于：准确识别新需求与程序既有功能之间的内在关联。</p>
<p>The kind of similarity that has to be per ceived is one between aspects of the world.</p>
<p>这种需要被识别的相似性，本质上是现实世界中各种实际情况之间的内在关联。</p>
<p>It only makes sense to the agent who has knowledge of the world, that is to the programmer, and cannot be reduced to any lim ited set of criteria or rules, for reasons similar to the ones given above why the justification of the program cannot be thus reduced.</p>
<p>这种理解只对掌握领域知识的程序员有意义，且无法简化为特定标准或规则，原因和之前论证程序合理性时说的完全一样。</p>
<p>While the discussion of the present section presents some basic arguments for adopting the Theory Building View of programming, an assessment of the view should take into account to what extent it may contribute to a coherent understanding of programming and its prob lems.</p>
<p>本节讨论虽为“编程即理论构建”观提供了基本论证，但评估该观点时仍需考量：它能在多大程度上推进对编程及其问题的系统性理解。</p>
<p>Such matters will be discussed in the following sections.</p>
<p>这些内容将在后续章节中讨论。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="程序修改的问题与成本"><a class="header" href="#程序修改的问题与成本">程序修改的问题与成本</a></h1>
<p>A prominent reason for proposing the Theory Building View of programming is the desire to establish an insight into programming suitable for supporting a sound understanding of program modifications.</p>
<p>提出“编程即理论构建”的根本动机是：建立对程序修改底层逻辑的深刻认知。</p>
<p>This question will therefore be the first one to be taken up for analysis.</p>
<p>因此，我们将首先对这一问题展开分析。</p>
<p>One thing seems to be agreed by everyone, that software will be modified.</p>
<p>有件事似乎是业界共识：软件终将被修改。</p>
<p>It is invariably the case that a program, once in operation, will be felt to be only part of the answer to the problems at hand.</p>
<p>程序一旦投入运行，人们总会发现它只能解决实际问题的某个方面。</p>
<p>Also the very use of the program itself will inspire ideas for further useful services that the program ought to provide.</p>
<p>程序的实际运行过程本身就会激发新的需求灵感，促使人们思考程序应当提供哪些新增的实用功能。</p>
<p>Hence the need for ways to handle modifications.</p>
<p>因此需要建立应对修改需求的方案。</p>
<p>The question of program modifications is closely tied to that of programming costs.</p>
<p>程序修改问题与开发成本问题密切相关。</p>
<p>In the face of a need for a changed manner of operation of the program, one hopes to achieve a saving of costs by making modifications of an existing program text, rather than by writing an entirely new program.</p>
<p>当需要改变程序运行方式时，人们认为修改现有代码通常比重写整个新程序更节省成本。</p>
<p>The expectation that program modifications at low cost ought to be possible is one that calls for closer analysis.</p>
<p>这种“低成本修改程序应该可行”的预期，需要深入分析。</p>
<p>First it should be noted that such an expectation cannot be supported by analogy with modifications of other complicated man–made constructions.</p>
<p>首先应当指出，这种预期无法通过类比其他复杂人造结构的修改来支持。</p>
<p>Where modifications are occasionally put into action, for example in the case of buildings, they are well known to be expensive and in fact complete demolition of the existing building followed by new construction is often found to be preferable economically.</p>
<p>例如在建筑领域，偶尔进行的改造项目其实成本高昂，事实上完全拆除重盖反而更划算。</p>
<p>Second, the expectation of the possibility of low cost program modifications conceivably finds support in the fact that a program is a text held in a medium allowing for easy editing.</p>
<p>其次，低成本修改程序的预期可能性源于程序文本存储在可编辑介质中的特性。</p>
<p>For this support to be valid it must clearly be assumed that the dominating cost is one of text manipulation.</p>
<p>要支持这一点有个前提：文本处理必须是核心开销。</p>
<p>This would agree with a notion of programming as text production.</p>
<p>这恰好符合“编程即代码产出”的观点。</p>
<p>On the Theory Building View this whole argument is false.</p>
<p>从“编程即理论构建”来看，这个观点是错误的。</p>
<p>This view gives no support to an expectation that program modifications at low cost are generally possible.</p>
<p>“编程即理论构建”不认同低成本程序修改普遍可行的预期。</p>
<p>A further closely related issue is that of program flexibility.</p>
<p>另一个密切关联的问题是程序的灵活性。</p>
<p>In including flexibility in a program we build into the program certain operational facilities that are not immediately demanded, but which are likely to turn out to be useful.</p>
<p>在程序中加入灵活性，意味着提前构建某些当前不需要但未来可能用到的功能。</p>
<p>Thus a flexible program is able to handle certain classes of changes of external circumstances without being modified.</p>
<p>具备灵活性的程序无需修改即可应对外部环境的特定变化。</p>
<p>It is often stated that programs should be designed to include a lot of flexibility, so as to be readily adaptable to changing circumstances.</p>
<p>人们常说程序应当设计得足够灵活，这样才能快速适应变化的需求。</p>
<p>Such advice may be reasonable as far as flexibility that can be easily achieved is concerned.</p>
<p>这类建议就易于实现的灵活性而言或许可取。</p>
<p>However, flexibility can in general only be achieved at a substantial cost.</p>
<p>然而，灵活性通常只能以相当大的成本实现。</p>
<p>Each item of it has to be designed, including what circumstances it has to cover and by what kind of parameters it should be controlled.</p>
<p>每一项灵活性功能的设计都需要确定：它需要覆盖哪些应用场景，以及通过何种参数进行控制。</p>
<p>Then it has to be implemented, tested, and described.</p>
<p>然后还要实现、测试和描述这些功能。</p>
<p>This cost is incurred in achieving a program feature whose usefulness depends entirely on future events.</p>
<p>这种成本是为实现一个其有用性完全取决于未来事件而产生的。</p>
<p>It must be obvious that built–in program flexibility is no answer to the general demand for adapting programs to the changing circumstances of the world.</p>
<p>显然，内置程序灵活性并非应对世界变化环境下对程序适应性普遍需求的解决方案。</p>
<p>In a program modification an existing programmed solution has to be changed so as to cater for a change in the real world activity it has to match.</p>
<p>修改程序时，必须调整现有方案来应对现实世界活动的变化。</p>
<p>What is needed in a modification, first of all, is a confrontation of the existing solution with the demands called for by the desired modification.</p>
<p>修改程序的第一件事，就是要评估现有方案与新修改需求是否匹配。</p>
<p>In this confrontation the degree and kind of similarity between the capabilities of the existing solution and the new demands has to be determined.</p>
<p>在此对比过程中，必须确定现有解决方案的能力与新需求之间的相似程度和类型。</p>
<p>This need for a determination of similarity brings out the merit of the Theory Building View.</p>
<p>这种对相似性的判定需求，恰好突显出“编程即理论构建”的核心价值。</p>
<p>Indeed, precisely in a determination of similarity the shortcoming of any view of programming that ignores the central requirement for the direct participation of persons who possess the appropriate insight becomes evident.</p>
<p>事实上，任何编程观点若绕开“需要核心洞察力持有者直接参与”这一点，在判定相似性时就会暴露出根本缺陷。</p>
<p>The point is that the kind of similarity that has to be recognized is accessible to the human beings who possess the theory of the program, although entirely outside the reach of what can be determined by rules, since even the criteria on which to judge it cannot be formulated.</p>
<p>关键在于：这种相似性的判定只有掌握程序理论的人才能做到，它完全超出规则可判定的范围，因为连判定标准本身都无从定义。</p>
<p>From the insight into the similarity between the new requirements and those already satisfied by the program, the programmer is able to design the change of the program text needed to implement the modification.</p>
<p>程序员通过洞察新需求与程序既有功能的相似性，就能精准设计出实现修改所需的代码改动。</p>
<p>In a certain sense there can be no question of a theory modification, only of a program modification.</p>
<p>从本质上说，需要修改的始终是程序而非理论。</p>
<p>Indeed, a person having the theory must already be prepared to respond to the kinds of questions and demands that may give rise to program modifications.</p>
<p>实际上，掌握理论的人随时能应对那些导致程序修改的问题和需求。</p>
<p>This observation leads to the important conclusion that the problems of program modification arise from acting on the assumption that programming consists of program text production, instead of recognizing programming as an activity of theory building.</p>
<p>程序修改的问题根源在于：人们错误地将编程等同于产出程序文本，而未能意识到编程本质上是构建理论的过程。</p>
<p>On the basis of the Theory Building View the decay of a program text as a result of modifications made by programmers without a proper grasp of the underlying theory becomes understandable.</p>
<p>由此，那些未能正确掌握基础理论的程序员修改代码导致程序质量退化的现象，基于“编程即理论构建”就能得到合理解释了。</p>
<p>As a matter of fact, if viewed merely as a change of the program text and of the external behaviour of the execution, a given desired modification may usually be realized in many different ways, all correct.</p>
<p>事实上，如果只关注程序代码和执行结果的变动，某个修改需求通常可以有多种实现方案，而且这些方案在技术上都能成立。</p>
<p>At the same time, if viewed in relation to the theory of the program these ways may look very different, some of them perhaps conforming to that theory or extending it in a natural way, while others may be wholly inconsistent with that theory, perhaps having the character of unintegrated patches on the main part of the program.</p>
<p>然而，若结合程序理论来审视，这些方案差异巨大：有些方案可能符合理论逻辑或自然扩展了理论，而另一些方案可能与理论完全冲突，表现为在程序主体上打零散的补丁。（译注：也就是堆屎山）</p>
<p>This difference of character of various changes is one that can only make sense to the programmer who possesses the theory of the program.</p>
<p>这种程序修改层面的本质差异，只有掌握程序理论的人才能真正理解。</p>
<p>At the same time the character of changes made in a program text is vital to the longer term viability of the program.</p>
<p>同时，程序代码的修改质量直接关乎程序的长远生命周期。</p>
<p>For a program to retain its quality it is mandatory that each modification is firmly grounded in the theory of it.</p>
<p>为了保持程序的质量，每次修改都必须牢固建立在其理论基础之上。</p>
<p>Indeed, the very notion of qualities such as simplicity and good structure can only be understood in terms of the theory of the program, since they characterize the actual program text in relation to such program texts that might have been written to achieve the same execution behaviour, but which exist only as possibilities in the programmer’s understanding.</p>
<p>程序质量的核心标准（如简洁性和结构性）只能通过程序理论来理解，因为这些标准本质上是将实际代码与程序员认知中那些能实现相同功能但未被编写的潜在方案进行对比的结果。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="程序的生命死亡与复活"><a class="header" href="#程序的生命死亡与复活">程序的生命、死亡与复活</a></h1>
<p>A main claim of the Theory Building View of programming is that an essential part of any program, the theory of it, is something that could not conceivably be expressed, but is inextricably bound to human beings.</p>
<p>“编程即理论构建”的核心主张是：任何程序的理论本质上无法被完整表达，且必然与人类认知紧密绑定。</p>
<p>It follows that in describing the state of the program it is important to indicate the extent to which programmers having its theory remain in charge of it.</p>
<p>描述程序生命状态时，必须明确掌握其理论的人员对该程序的实际掌控程度。</p>
<p>As a way in which to emphasize this circumstance one might extend the notion of program building by notions of program life, death, and revival.</p>
<p>为强调这一状况，可通过引入程序生命、死亡与复活的概念来扩展程序构建的内涵。</p>
<p>The building of the program is the same as the building of the theory of it by and in the team of programmers.</p>
<p>程序的构建过程，就是程序员团队在其内部构建相关理论的过程。</p>
<p>During the program life a programmer team possessing its theory remains in active control of the program, and in particular retains control over all modifications.</p>
<p>在程序生命期间，掌握其理论知识的程序员团队持续主导程序，特别是掌控所有修改权。</p>
<p>The death of a program happens when the programmer team possessing its theory is dissolved.</p>
<p>程序的死亡发生在掌握其理论的程序员团队解散时。</p>
<p>A dead program may continue to be used for execution in a computer and to produce useful results.</p>
<p>一个死亡的程序仍可在计算机中运行并产出有用结果。</p>
<p>The actual state of death becomes visible when demands for modifications of the program cannot be intelligently answered.</p>
<p>当修改需求无法得到专业回应时，程序的实际死亡状态就显现出来了。</p>
<p>Revival of a program is the rebuilding of its theory by a new programmer team.</p>
<p>程序的复活是指新程序员团队重建其理论的过程。</p>
<p>The extended life of a program according to these notions depends on the taking over by new generations of programmers of the theory of the program.</p>
<p>根据这些概念，程序的寿命取决于新一代程序员能否继承该程序的理论。</p>
<p>For a new programmer to come to possess an existing theory of a program it is insufficient that he or she has the opportunity to become familiar with the program text and other documentation.</p>
<p>新程序员若想掌握既有程序理论，仅靠熟悉程序文本和相关文档是远远不够的。</p>
<p>What is required is that the new programmer has the opportunity to work in close contact with the programmers who already possess the theory, so as to be able to become familiar with the place of the program in the wider context of the relevant real world situations and so as to acquire the knowledge of how the program works and how unusual program reactions and program modifications are handled within the program theory.</p>
<p>新程序员必须有机会与掌握理论的原团队紧密协作，通过参与相关现实场景实践来理解程序的定位，并学习程序运作机制及程序理论框架下如何处理异常反应和修改需求。</p>
<p>This problem of education of new programmers in an existing theory of a program is quite similar to that of the educational problem of other activities where the knowledge of how to do certain things dominates over the knowledge that certain things are the case, such as writing and playing a music instrument.</p>
<p>新程序员学习已有程序理论的培养问题，本质上类似音乐创作或乐器演奏，核心在于实践经验的传递，而非理论知识灌输。</p>
<p>The most important educational activity is the student’s doing the relevant things under suitable supervision and guidance.</p>
<p>最重要的教育方式就是让学生在专业指导下动手实践。</p>
<p>In the case of programming the activity should include discussions of the relation between the program and the relevant aspects and activities of the real world, and of the limits set on the real world matters dealt with by the program.</p>
<p>在编程领域，最关键的实践教学要包含两项内容：讨论程序与现实世界的具体关联，以及明确程序处理现实事务的边界。</p>
<p>A very important consequence of the Theory Building View is that program revival, that is reestablishing the theory of a program merely from the documentation, is strictly impossible.</p>
<p>“编程即理论构建”一个重要的结论是：仅凭文档绝对无法复活程序（即重建其理论）。</p>
<p>Lest this consequence may seem unreasonable it may be noted that the need for revival of an entirely dead program probably will rarely arise, since it is hardly conceivable that the revival would be assigned to new programmers without at least some knowledge of the theory had by the original team.</p>
<p>退一万步说，即便程序复活看似不可行，但现实中完全死亡的程序需要复活的情况也极少，毕竟很难想象会让对原始理论毫无了解的新团队执行复活任务。</p>
<p>Even so the Theory Building View suggests strongly that program revival should only be attempted in exceptional situations and with full awareness that it is at best costly, and may lead to a revived theory that differs from the one originally had by the program authors and so may contain discrepancies with the program text.</p>
<p>即便如此，“编程即理论构建”仍然强烈主张：程序复活只能在极特殊情况下尝试，且必须事先有心理准备，即便成功也要付出高昂代价，甚至复活后的理论可能偏离原团队的认知，与程序代码遗留潜在冲突。</p>
<p>In preference to program revival, the Theory Building View suggests, the existing program text should be discarded and the new–formed programmer team should be given the opportunity to solve the given problem afresh.</p>
<p>“编程即理论构建”主张：与其复活旧程序，不如放弃现有代码，让新团队从头解决原始问题。</p>
<p>Such a procedure is more likely to produce a viable program than program revival, and at no higher, and possibly lower, cost.</p>
<p>这种做法比复活程序更可能产出可行程序，成本相当甚至更低。</p>
<p>The point is that building a theory to fit and support an existing program text is a difficult, frustrating, and time consuming activity.</p>
<p>关键在于：强行根据现有代码反推理论体系，是个极其痛苦、挫败且耗时的过程。​</p>
<p>The new programmer is likely to feel torn between loyalty to the existing program text, with whatever obscurities and weaknesses it may contain, and the new theory that he or she has to build up, and which, for better or worse, most likely will differ from the original theory behind the program text.</p>
<p>新程序员会陷入撕裂感：既要忠于可能晦涩脆弱的现有代码，又必须构建新理论体系。而无论好坏，新理论几乎必然偏离代码背后的原始设计理念。</p>
<p>Similar problems are likely to arise even when a program is kept continuously alive by an evolving team of programmers, as a result of the differences of competence and background experience of the individual programmers, particularly as the team is being kept operational by inevitable replacements of the individual members.</p>
<p>即便在持续维护的程序中，随着程序员团队的人员更替和个体能力差异，最终也会出现类似问题，团队对程序理论的理解会不断偏离最初版本。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编程方法和理论构建"><a class="header" href="#编程方法和理论构建">编程方法和理论构建</a></h1>
<p>Recent years has seen much interest in programming methods.</p>
<p>近年来，编程方法备受瞩目。</p>
<p>In the present section some comments will be made on the relation between the Theory Building View and the notions behind programming methods.</p>
<p>本文最后将探讨“编程即理论构建”与现有编程方法之间的关联。</p>
<p>To begin with, what is a programming method? This is not always made clear, even by authors who recommend a particular method.</p>
<p>首先，什么是编程方法？这一点往往并不明确，即使那些推荐具体编程方法的人，也未必能清晰阐述。</p>
<p>Here a programming method will be taken to be a set of work rules for programmers, telling what kind of things the programmers should do, in what order, which notations or languages to use, and what kinds of documents to produce at various stages.</p>
<p>在此，编程方法将被定义为一套针对程序员的工作规则：规定他们该做什么、按什么顺序做、使用哪些符号或语言，以及在不同阶段要产出哪些文档。</p>
<p>In comparing this notion of method with the Theory Building View of programming, the most important issue is that of actions or operations and their ordering.</p>
<p>关键点在于：现有编程方法与“编程即理论构建”的核心差异在于操作步骤及其顺序。</p>
<p>A method implies a claim that program development can and should proceed as a sequence of actions of certain kinds, each action leading to a particular kind of documented result.</p>
<p>编程方法的核心理念是：程序开发应该按特定步骤序列执行，每个步骤会产出对应的交付物。</p>
<p>In building the theory there can be no particular sequence of actions, for the reason that a theory held by a person has no inherent division into parts and no inherent ordering.</p>
<p>在理论构建过程中不可能有固定操作序列，因为人类掌握的理论本身没有固有组成部分或顺序。</p>
<p>Rather, the person possessing a theory will be able to produce presentations of various sorts on the basis of it, in response to questions or demands.</p>
<p>相反，真正掌握理论的人能根据不同问题或需求，基于理论产出多种形式的阐述。</p>
<p>As to the use of particular kinds of notation or formalization, again this can only be a secondary issue since the primary item, the theory, is not, and cannot be, expressed, and so no question of the form of its expression arises.</p>
<p>对于特定符号或形式化的使用，这只能是次要问题。因为核心的理论本身无法被表达，因此也就不存在其表达形式的问题。</p>
<p>It follows that on the Theory Building View, for the primary activity of the programming there can be no right method.</p>
<p>根据“编程即理论构建”，对于编程最核心的活动而言，不存在所谓唯一正确的方法。</p>
<p>This conclusion may seem to conflict with established opinion, in several ways, and might thus be taken to be an argument against the Theory Building View.</p>
<p>这个结论看似与主流观点存在多处矛盾，甚至可能被当作反驳“编程即理论构建”的依据。</p>
<p>Two such apparent contradictions shall be taken up here, the first relating to the importance of method in the pursuit of science, the second concerning the success of methods as actually used in software development.</p>
<p>这里将讨论两个看似矛盾的观点：一是科学探究中方法的重要性，二是软件开发中实际采用的方法论的成效。</p>
<p>The first argument is that software development should be based on scientific manners, and so should employ procedures similar to scientific methods.</p>
<p>第一个观点认为：软件开发应遵循科学规范，采用类似科学方法的操作步骤。</p>
<p>The flaw of this argument is the assumption that there is such a thing as scientific method and that it is helpful to scientists.</p>
<p>这个观点的根本错误在于：它认为存在某种科学方法且这种方法对科学家有帮助。</p>
<p>This question has been the subject of much debate in recent years, and the conclusion of such authors as Feyerabend [2], taking his illustrations from the history of physics, and Medawar [5], arguing as a biologist, is that the notion of scientific method as a set of guidelines for the practising scientist is mistaken.</p>
<p>近年来这个问题争议不断，像 Feyerabend [2]（以物理学史为例）和 Medawar [5]（从生物学角度论证）等学者得出结论：将科学方法视为科学家实践指南的观念是错误的。</p>
<p>This conclusion is not contradicted by such work as that of Polya [8, 9] on problem solving.</p>
<p>这一结论与 Polya [8,9] 关于解题方法的研究成果并不矛盾。</p>
<p>This work takes its illustrations from the field of mathematics and leads to insight which is also highly relevant to programming.</p>
<p>这项研究以数学领域的案例为基础，得出的见解对编程领域也高度相关。</p>
<p>However, it cannot be claimed to present a method on which to proceed.</p>
<p>但绝不能宣称它提供了可遵循的方法。</p>
<p>Rather, it is a collection of suggestions aiming at stimulating the mental activity of the problem solver, by pointing out different modes of work that may be applied in any sequence.</p>
<p>相反，它更像是解题思路的催化剂：通过指出各种可任意组合的工作模式，激发解题者的思维活力。</p>
<p>The second argument that may seem to contradict the dismissal of method of the Theory Building View is that the use of particular methods has been successful, according to published reports.</p>
<p>第二个看似与“编程即理论构建”对方法的否定相矛盾的论点是：据报告，特定编程方法在实践应用中已取得成效。</p>
<p>To this argument it may be answered that a methodically satisfactory study of the efficacy of programming methods so far never seems to have been made.</p>
<p>但迄今为止，似乎从未有人真正做过严谨论证编程方法成效的研究。</p>
<p>Such a study would have to employ the well established technique of controlled experiments (cf. Brooks, 1980 [1] or Moher and Schneider, 1982 [6]).</p>
<p>这项研究必须采用成熟的对照实验技术（参见 Brooks, 1980 [1] 或 Moher &amp; Schneider, 1982 [6]）。</p>
<p>The lack of such studies is explainable partly by the high cost that would undoubtedly be incurred in such investigations if the results were to be significant, partly by the problems of establishing in an operational fashion the concepts underlying what is called methods in the field of program development.</p>
<p>这种研究的缺失部分归因于高昂成本（若得出有效结论则成本必然巨大），部分在于难以在实际操作中准确定义程序开发领域所谓编程方法的核心理念。</p>
<p>Most published reports on such methods merely describe and recommend certain techniques and procedures, without establishing their usefulness or efficacy in any systematic way.</p>
<p>现有的大多数相关编程方法报告，都仅停留在描述和推荐某些技巧及流程层面，而绝非通过系统方法实证其实际效用。</p>
<p>An elaborate study of five different methods by C. Floyd and several co–workers [3] concludes that the notion of methods as systems of rules that in an arbitrary context and mechanically will lead to good solutions is an illusion.</p>
<p>C. Floyd 与多位合作者 [3] 对五种编程方法展开深入研究，最终得出结论：认为存在某种规则体系能机械式导出优质解决方案的想法纯属幻想。</p>
<p>What remains is the effect of methods in the education of programmers. This conclusion is entirely compatible with the Theory Building View of programming.</p>
<p>编程方法的真正价值体现在程序员的教育上。这一点与“编程即理论构建”完全相容。</p>
<p>Indeed, on this view the quality of the theory built by the programmer will depend to a large extent on the programmer’s familiarity with model solutions of typical problems, with techniques of description and verification, and with principles of structuring systems consisting of many parts in complicated interactions.</p>
<p>实际上，程序员构建的理论质量主要取决于三点：对典型问题的模型解决方案的熟悉度、对描述与验证技术的掌握程度、以及对多部件复杂交互系统的构建原则的理解深度。</p>
<p>Thus many of the items of concern of methods are relevant to theory building.</p>
<p>编程方法的诸多关注点其实都涉及理论构建的核心范畴。</p>
<p>Where the Theory Building View departs from that of the methodologists is on the question of which techniques to use and in what order.</p>
<p>“编程即理论构建”与编程方法的根本分歧在于：使用何种技术以及采用什么顺序。</p>
<p>On the Theory Building View this must remain entirely a matter for the programmer to decide, taking into account the actual problem to be solved.</p>
<p>根据“编程即理论构建”的观点，程序员必须完全根据实际要解决的问题来自行决定这些事项。</p>
<hr />
<ol>
<li>Brooks, R. E. Studying programmer behaviour experimentally. Comm. ACM 23(4): 207–213, 1980.</li>
<li>Feyerabend, P. Against Method. London, Verso Editions, 1978; ISBN: 86091–700–2.</li>
<li>Floyd, C. Eine Untersuchung von Software–Entwicklungs–Methoden. Pp. 248–274 in Programmierumgebungen und Compiler, ed H. Morgenbrod and W. Sammer, Tagung I/1984 des German Chapter of the ACM, Stuttgart, Teubner Verlag, 1984; ISBN: 3–519–02437–3.</li>
<li>Kuhn, T.S. The Structure of Scientific Revolutions, Second Edition. Chicago, University of Chicago Press, 1970; ISBN: 0–226–45803–2.</li>
<li>Medawar, P. Pluto’s Republic. Oxford, University Press, 1982: ISBN: 0–19–217726–5.</li>
<li>Moher, T., and Schneider, G. M. Methodology and experimental research in software engineering, Int. J. Man–Mach. Stud. 16: 65–87, 1. Jan. 1982.</li>
<li>Oskarsson, ¨O Mechanisms of modifiability in large software systems Link¨oping Studies in Science and Technology, Dissertations, no. 77, Link¨oping, 1982; ISBN: 91–7372–527–7.</li>
<li>Polya, G. How To Solve It . New York, Doubleday Anchor Book, 1957.</li>
<li>Polya, G. Mathematics and Plausible Reasoning. New Jersey, Princeton University Press, 1954.</li>
<li>Popper, K. R., and Eccles, J. C. The Self and Its Brain. London, Routledge and Kegan Paul, 1977.</li>
<li>Ryle, G. The Concept of Mind. Harmondsworth, England, Penguin, 1963, first published 1949. Applying “Theory Building”</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="程序员的地位与理论构建观点"><a class="header" href="#程序员的地位与理论构建观点">程序员的地位与理论构建观点</a></h1>
<p>The areas where the consequences of the Theory Building View contrast most strikingly with those of the more prevalent current views are those of the programmers’ personal contribution to the activity and of the programmers’ proper status.</p>
<p>“编程即理论构建”与当前主流观点最惊人的差异在于：程序员对编程活动的个人贡献及其专业地位的认定。</p>
<p>The contrast between the Theory Building View and the more prevalent view of the programmers’ personal contribution is apparent in much of the common discussion of programming.</p>
<p>在多数关于编程的讨论中，“编程即理论构建”与主流观点在程序员个人贡献层面的冲突显而易见。</p>
<p>As just one example, consider the study of modifiability of large software systems by Oskarsson [7].</p>
<p>以 Oskarsson [7] 对大型软件系统可修改性的研究为例：​</p>
<p>This study gives extensive information on a considerable number of modifications in one release of a large commercial system.</p>
<p>这项研究详细记录了一个大型商业系统在单次版本更新中的大量修改情况。</p>
<p>The description covers the background, substance, and implementation, of each modification, with particular attention to the manner in which the program changes are confined to particular program modules.</p>
<p>该研究详细记录了每次修改的背景、内容和实现过程，尤其关注程序变更如何限定在特定模块内。</p>
<p>However, there is no suggestion whatsoever that the implementation of the modifications might depend on the background of the 500 programmers employed on the project, such as the length of time they have been working on it, and there is no indication of the manner in which the design decisions are distributed among the 500 programmers.</p>
<p>然而研究完全未涉及以下关键因素：500 名程序员的项目经验（例如参与时长）、技术决策权在团队中的具体分配机制。</p>
<p>Even so the significance of an underlying theory is admitted indirectly in statements such as that ‘decisions were implemented in the wrong block’ and in a reference to ‘a philosophy of AXE’.</p>
<p>研究仍通过“决策被错误地实施在错误的模块中”及“AXE 系统设计哲学”等表述，间接承认了底层理论的存在价值。</p>
<p>However, by the manner in which the study is conducted these admissions can only remain isolated indications.</p>
<p>该研究的方法论缺陷导致这些关键发现只能作为割裂的理论痕迹呈现，无法系统化展现程序理论体系。</p>
<p>More generally, much current discussion of programming seems to assume that programming is similar to industrial production, the programmer being regarded as a component of that production, a component that has to be controlled by rules of procedure and which can be replaced easily.</p>
<p>更普遍地说，当前许多编程讨论似乎默认编程类似工业生产，程序员被视为生产线上受规则约束的零件，可随意替换。</p>
<p>Another related view is that human beings perform best if they act like machines, by following rules, with a consequent stress on formal modes of expression, which make it possible to formulate certain arguments in terms of rules of formal manipulation.</p>
<p>另一种相关观点认为：人类只有像机器般遵循规则才能发挥最佳效能，这导致过度强调形式化表达方式，因为只有形式化才能用操作规则来论证逻辑。</p>
<p>Such views agree well with the notion, seemingly common among persons working with computers, that the human mind works like a computer.</p>
<p>这种观点恰好契合计算机从业者中普遍存在的观念：人脑的运作机制与计算机相同。</p>
<p>At the level of industrial management these views support treating programmers as workers of fairly low responsibility, and only brief education.</p>
<p>在工业管理层面，这类观念支持将程序员视为责任较轻、仅需简短培训的普通工人。</p>
<p>On the Theory Building View the primary result of the programming activity is the theory held by the programmers.</p>
<p>在“编程即理论构建”视角下，编程活动的主要成果是程序员掌握的理论。</p>
<p>Since this theory by its very nature is part of the mental possession of each programmer, it follows that the notion of the programmer as an easily replaceable component in the program production activity has to be abandoned.</p>
<p>因为程序理论本质上是每个程序员独有的认知资产，所以必须摒弃将程序员视为程序生产中可替换零件的观念。</p>
<p>Instead the programmer must be regarded as a responsible developer and manager of the activity in which the computer is a part.</p>
<p>相反，程序员应被视为人机协作活动中负责的开发管理者。</p>
<p>In order to fill this position he or she must be given a permanent position, of a status similar to that of other professionals, such as engineers and lawyers, whose active contributions as employers of enterprises rest on their intellectual proficiency.</p>
<p>为了担任这一角色，他或她必须获得一个永久职位，其地位应与其他专业人士（如工程师和律师）相当，这些专业人士为企业雇主的积极贡献基于其智力专业能力。</p>
<p>The raising of the status of programmers suggested by the Theory Building View will have to be supported by a corresponding reorientation of the programmer education.</p>
<p>根据“编程即理论构建”的观点，要提升程序员地位，必须同步调整程序员教育方向。</p>
<p>While skills such as the mastery of notations, data representations, and data processes, remain important, the primary emphasis would have to turn in the direction of furthering the understanding and talent for theory formation.</p>
<p>虽然掌握符号系统、数据表示和流程处理等技能仍然重要，但教育的核心重点必须转向培养学生构建理论的理解力和能力。</p>
<p>To what extent this can be taught at all must remain an open question.</p>
<p>这种能力是否真能教授，在多大程度上可以教授，仍是一个开放的问题。</p>
<p>The most hopeful approach would be to have the student work on concrete problems under guidance, in an active and constructive environment.</p>
<p>最有希望的教学方法是让学生在积极创新的环境中，通过专业指导动手解决实际问题。</p>
<hr />
<ol>
<li>Brooks, R. E. Studying programmer behaviour experimentally. Comm. ACM 23(4): 207–213, 1980.</li>
<li>Feyerabend, P. Against Method. London, Verso Editions, 1978; ISBN: 86091–700–2.</li>
<li>Floyd, C. Eine Untersuchung von Software–Entwicklungs–Methoden. Pp. 248–274 in Programmierumgebungen und Compiler, ed H. Morgenbrod and W. Sammer, Tagung I/1984 des German Chapter of the ACM, Stuttgart, Teubner Verlag, 1984; ISBN: 3–519–02437–3.</li>
<li>Kuhn, T.S. The Structure of Scientific Revolutions, Second Edition. Chicago, University of Chicago Press, 1970; ISBN: 0–226–45803–2.</li>
<li>Medawar, P. Pluto’s Republic. Oxford, University Press, 1982: ISBN: 0–19–217726–5.</li>
<li>Moher, T., and Schneider, G. M. Methodology and experimental research in software engineering, Int. J. Man–Mach. Stud. 16: 65–87, 1. Jan. 1982.</li>
<li>Oskarsson, ¨O Mechanisms of modifiability in large software systems Link¨oping Studies in Science and Technology, Dissertations, no. 77, Link¨oping, 1982; ISBN: 91–7372–527–7.</li>
<li>Polya, G. How To Solve It . New York, Doubleday Anchor Book, 1957.</li>
<li>Polya, G. Mathematics and Plausible Reasoning. New Jersey, Princeton University Press, 1954.</li>
<li>Popper, K. R., and Eccles, J. C. The Self and Its Brain. London, Routledge and Kegan Paul, 1977.</li>
<li>Ryle, G. The Concept of Mind. Harmondsworth, England, Penguin, 1963, first published 1949. Applying “Theory Building”</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结论"><a class="header" href="#结论">结论</a></h1>
<p>Accepting program modifications demanded by changing external circumstances to be an essential part of programming, it is argued that the primary aim of programming is to have the programmers build a theory of the way the matters at hand may be supported by the execution of a program.</p>
<p>既然程序修改是编程的本质部分，那么编程的核心目标就是让程序员构建理论：理解程序如何支撑现实事务运行。</p>
<p>Such a view leads to a notion of program life that depends on the continued support of the program by programmers having its theory.</p>
<p>这种观点引申出程序生命的概念，即程序的生命周期完全依赖掌握该程序理论的程序员团队的持续支持。</p>
<p>Further, on this view the notion of a programming method, understood as a set of rules of procedure to be followed by the programmer, is based on invalid assumptions and so has to be rejected.</p>
<p>此外，从这种观点来看：将编程方法理解为程序员必须遵循的操作规则，本质上是基于错误前提的，必须被彻底摒弃。</p>
<p>As further consequences of the view, programmers have to be accorded the status of responsible, permanent developers and managers of the activity of which the computer is a part, and their education has to emphasize the exercise of theory building, side by side with the acquisition of knowledge of data processing and notations.</p>
<p>基于此观点的进一步思考，程序员必须被赋予责任主体地位：作为人机协作活动的核心开发者与管理者，其教育体系需在数据加工及符号系统训练之外，同步强化理论构建能力的培养。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="应用理论构建"><a class="header" href="#应用理论构建">应用「理论构建」</a></h1>
<p>Viewing programming as theory building helps us understand “metaphor building” activity in Extreme Programming (XP), and the respective roles of tacit knowledge and documentation in passing along design knowledge.</p>
<p>将编程视为理论构建，有助于理解极限编程(XP)中的“隐喻构建”活动，以及隐性知识与文档在设计知识传承中的各自作用。</p>
<h2 id="the-metaphor-as-a-theory-隐喻作为理论"><a class="header" href="#the-metaphor-as-a-theory-隐喻作为理论">The Metaphor as a Theory. 隐喻作为理论。</a></h2>
<p>Kent Beck suggested that it is useful to a design team to simplify the general design of a program to match a single metaphor.</p>
<p>Kent Beck 认为，设计团队将程序的整体设计简化为适配某个单一隐喻会很有帮助。</p>
<p>Examples might be, “This program really looks like an assembly line, with things getting added to a chassis along the line,” or “This program really looks like a restaurant, with waiters and menus, cooks and cashiers.” If the metaphor is good, the many associations the designers create around the metaphor turn out to be appropriate to their programming situation.</p>
<p>例如：“这个程序本质上像流水线，零件在传送带上堆叠成底盘”，或“这个程序就像餐厅，有服务员、菜单、厨师和收银员”。如果隐喻恰当，设计团队围绕隐喻产生的诸多设计思路，会正好能套用到实际编程场景中。</p>
<p>That is exactly Naur’s idea of passing along a theory of the design.</p>
<p>这正是 Naur 理论的核心：设计理念的传承本质。</p>
<p>If “assembly line” is an appropriate metaphor, then later programmers, considering what they know about assembly lines, will make guesses about the structure of the software at hand and find that their guesses are “close.” That is an extraordinary power for just the two words, “assembly line.” The value of a good metaphor increases with the number of designers.</p>
<p>当“流水线”成为恰当隐喻时，后续程序员基于对流水线的认知，能准确推测现有软件结构并验证其合理性。两个单词就形成如此强大的设计引导力，这正是隐喻的核心价值，且设计团队规模越大其效应越显著。</p>
<p>The closer each person’s guess is “close” to the other people’s guesses, the greater the resulting consistency in the final system design.</p>
<p>每个成员的设计构思越“趋近”彼此，最终系统的设计一致性就越高。</p>
<p>Imagine 10 programmers working as fast as they can, in parallel, each making design decisions and adding classes as she goes.</p>
<p>想象一下：10 名程序员火力全开并行工作，每个成员边开发边做设计决策，随时添加新类。</p>
<p>Each will necessarily develop her own theory as she goes.</p>
<p>每个成员在开发过程中都会形成自己的理论体系。</p>
<p>As each adds code, the theory that binds their work becomes less and less coherent, more and more complicated.</p>
<p>每个程序员添加的代码越多，整个项目的理论框架就 ​​ 越来越松散，越来越复杂 ​​。</p>
<p>Not only maintenance gets harder, but their own work gets harder.</p>
<p>不仅维护变得困难，他们自己的工作也变得困难。</p>
<p>The design easily becomes a “kludge.” If they have a common theory, on the other hand, they add code in ways that fit together.</p>
<p>设计很容易变成“混乱拼凑”。反之若团队拥有共同理论，代码就能以协调统一的方式叠加。</p>
<p>An appropriate, shared metaphor lets a person guess accurately where someone else on the team just added code, and how to fit her new piece in with it.</p>
<p>恰当的共享隐喻能让团队成员准确推测他人新增的代码位置，并衔接好自己的新增模块。</p>
<h2 id="tacit-knowledge-and-documentation-隐性知识与文档"><a class="header" href="#tacit-knowledge-and-documentation-隐性知识与文档">Tacit Knowledge and Documentation. 隐性知识与文档。</a></h2>
<p>The documentation is almost certainly behind the current state of the program, but people are good at looking around.</p>
<p>文档几乎肯定落后于代码的最新状态，但程序员擅长自己查代码找答案。</p>
<p>What should you put into the documentation? That which helps the next programmer build an adequate theory of the program. This is enormously important.</p>
<p>文档应记录能帮助后续程序员构建程序理论体系的内容。这点至关重要。</p>
<p>The purpose of the documentation is to jog memories in the reader, set up relevant pathways of thought about experiences and metaphors.</p>
<p>文档的核心价值在于唤醒读者的记忆，激活其关于经验和隐喻的思维路径。</p>
<p>This sort of documentation is more stable over the life of the program than just naming the pieces of the system currently in place.</p>
<p>这种文档在程序生命周期中，比单纯记录当前系统组件名称更具稳定性。</p>
<p>The designers are allowed to use whatever forms of expression are necessary to set up those relevant pathways.</p>
<p>允许设计者采用一切必要的表达形式，只要能激活这些思维路径。</p>
<p>They can even use multiple metaphors, if they don’t find one that is adequate for the entire program.</p>
<p>若找不到覆盖整个程序的恰当隐喻，设计者甚至可以组合使用多个隐喻。</p>
<p>They might say that one section implements a fractal compression algorithm, a second is like an accounting ledger, the user interface follows the model-observer design pattern, and so on.</p>
<p>可以这样描述：某个模块实现了分形压缩算法，另一模块如同会计账簿，用户界面则采用模型-观察者设计模式等等。</p>
<p>Experienced designers often start their documentation with just:</p>
<p>资深设计师的文档通常仅包含三要素：</p>
<ul>
<li>The metaphors 所用隐喻</li>
<li>Text describing the purpose of each major component 各核心模块的核心任务说明</li>
<li>Drawings of the major interactions between the major components 主要模块间的交互流程示意图</li>
</ul>
<p>These three items alone take the next team a long way to constructing a useful theory of the design.</p>
<p>仅靠这三要素，后续团队就能高效复现设计理论的核心框架。</p>
<p>The source code itself serves to communicate a theory to the next programmer.</p>
<p>源代码本身的作用，是向后续程序员表达程序设计的核心思想。</p>
<p>Simple, consistent naming conventions help the next person build a coherent theory.</p>
<p>简单一致的命名规则能帮助后续程序员构建连贯的理论体系。</p>
<p>When people talk about “clean code,” a large part of what they are referring to is how easily the reader can build a coherent theory of the system.</p>
<p>当人们谈论“简洁代码”时，本质上是指阅读者能否轻松构建出系统的理论框架。</p>
<p>Documentation cannot—and so need not—say everything.</p>
<p>文档永远无法记录一切，所以也无需面面俱到。</p>
<p>Its purpose is to help the next programmer build an accurate theory about the system.</p>
<p>文档的核心作用是帮助后续程序员构建关于系统的准确理论体系。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
